[{"title":"基于Gin搭建项目框架并集成Nacos实现服务注册","url":"/2023/01/25/%E5%9F%BA%E4%BA%8EGin%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E5%B9%B6%E9%9B%86%E6%88%90Nacos%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/","content":"一、Windows 如何搭建 Go 环境1、下载 Go 语言开发包可以到 Go 语言开发官网下载 Windows 系统下的Go语言开发包，如下图所示：\n2、安装 Go 语言开发包双击下载好的 Go 语言开发包即可启动安装程序，如下图所示，直接勾选“I accept …”然后点击“Next”即可在 Windows 系统下 Go 语言开发包会默认安装到 C 盘的 Go 目录下，推荐在这个目录下安装，使用起来较为方便。当然，也可以选择其他的安装目录，确认无误后点击“Next”，如下图所示：Go语言开发包的安装没有其他需要设置的选项，点击“Install”即可开始安装安装完成后，在我们所设置的安装目录下将生成一些目录和文件，如下图所示：\n3、设置环境变量开发包安装完成后，还需要配置一下GOPATH 环境变量，之后才可以使用Go语言进行开发。GOPATH 是一个路径，用来存放开发中需要用到的代码包在弹出的菜单里找到 GOPATH 对应的选项点击编辑之后就可以修改了，没有的话可以选择新建，并将变量名填写为 GOPATH，变量值设置为任意目录均可（尽量选择空目录），例如 D:\\Go\n4、下载开发工具并设置环境变量Go 项目开发需要使用 GoLand 开发工具进行开发，需要从官网上下载对应的安装包，并配置对应的 GOROOT地址【选择自己安装的 Go 语言开发包的位置】配置GOPATH\n二、Golang 的项目框架是什么样子的？目前构建 Go 项目普遍参考的项目结构: golang-standards 其中构建的项目结构是 Go 应用程序项目的基础布局，包含中文README文件阅读\n\n&#x2F;internal\n私有的应用程序代码库：这些是不希望被其他人导入的代码，在项目的目录树中的任意位置都可以有internal目录，而不仅仅是在顶级目录中\n\n\n&#x2F;pkg\n外部应用程序可以使用的库代码：比如项目中公用封装的工具类等\n\n\n&#x2F;vendor\n包含所有依赖的三方的源代码\n\n\n\n三、什么是Gin,应该如何使用？Gin 是一个用 Go (Golang) 编写的 HTTP web 框架，可以传入一些Http请求下载并安装Gin：\n\ngo get -u github.com&#x2F;gin-gonic&#x2F;gin\nimport “github.com&#x2F;gin-gonic&#x2F;gin”\nimport “net&#x2F;http”[可选，会提供一些http响应的状态常量]\n\n使用基本例子：\n四、如何集成Nacos集成服务注册与配置文件的动态读取Nacos-sdk-go是Nacos的Go语言客户端，它实现了服务发现和动态配置的功能配置过程：\nvar (    Db             *gorm.DB    LOG            *zap.SugaredLogger    CONFIG         conf.Config    WechatOfficial *officialaccount.OfficialAccount)// 加载配置，失败直接panicfunc LoadConfig() &#123;    //服务注册端口和地址    serverConfigs := []constant.ServerConfig&#123;        &#123;            IpAddr: &quot;Nacos注册地址&quot;,            Port:   8848,        &#125;,    &#125;    // 客户端配置    clientConfig := constant.ClientConfig&#123;        //http请求超时时间，单位毫秒        TimeoutMs:           5000,        NotLoadCacheAtStart: true,        NamespaceId:         &quot;注册的命名空间&quot;,        ListenInterval:      10000,    &#125;    //创建动态配置客户端    configClient, err := clients.NewConfigClient(        vo.NacosClientParam&#123;            ClientConfig:  &amp;clientConfig,            ServerConfigs: serverConfigs,        &#125;,    )    // 创建服务发现客户端的另一种方式 (推荐)    client, err := clients.NewNamingClient(        vo.NacosClientParam&#123;            ClientConfig:  &amp;clientConfig,            ServerConfigs: serverConfigs,        &#125;,    )    if err != nil &#123;        panic(err)    &#125;    //服务注册    success, err := client.RegisterInstance(vo.RegisterInstanceParam&#123;        Ip:          utils.LocalIP(),        Port:        &#x27;项目端口号&#x27;,        ServiceName: &quot;项目注册的服务名&quot;,        Weight:      10,        Enable:      true,        Healthy:     true,        Ephemeral:   true,    &#125;)    if !success &#123;        return    &#125;    //获取配置    content, err := configClient.GetConfig(        vo.ConfigParam&#123;            DataId: &quot;Nacos上配置的配置文件名&quot;,            Group:  &quot;DEFAULT_GROUP&quot;&#125;)    viper := viper.New()    v := viper    //配置读取文件类型    v.SetConfigType(&quot;yaml&quot;)    //读取配置文件内容    v.ReadConfig(strings.NewReader(content))    //监听配置文件变动，重新解析配置    v.OnConfigChange(func(in fsnotify.Event) &#123;        if err := v.Unmarshal(&amp;CONFIG); err != nil &#123;            panic(err)        &#125;    &#125;)    //将配置映射成结构体    if err := v.Unmarshal(&amp;CONFIG); err != nil &#123;        panic(err)    &#125;&#125;\n","categories":["环境搭建"],"tags":["Go"]},{"title":"SpringBoot基础及概念入门","url":"/2022/10/22/SpringBoot%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/","content":"一、SpringBoot产生的背景1、产生背景\n在SpringBoot出现之前，使用Spring需要大量的xml文件配置【配置地狱】，2013年SpringBoot的诞生就实现了免XML配置和提供更佳开发体验的目标\n\n2、使用SpringBoot的便利性\n使配置变简单\n使开发变简单\n使控制变简单\n使部署变简单\n\n3、SpringBoot的主要特性\n约定大于配置\n内嵌Servlet容器，应用jar包执行\n快速完成项目搭建、整合第三方类库，方便易用\n提供starter POM方便进行包管理\n\n4、Spring Boot、Spring MVC、Spring对比\nSpring框架最核心的特性就是依赖注入DI(Dependency Injection)和控制反转IOC(Inversion Of Control)\nSpring MVC 提供一种有好的方式开发web控制程序\nSpringBoot 自动配置 约定大于配置\n\n5、彩蛋\n百度指数：https://index.baidu.com/v2/index.html#/\n\n二、创建HelloWorld及项目结构介绍\n在IDEA创建Spring Initializr项目，保证联网\n选择Spring Web依赖\n修改父功能的packaging类型为pom\n在父项目上创建新的module即可\n启动主类\n\n@SpringBootApplicationpublic class HelloWorldApplication&#123;    public static void main(String[] args)&#123;        SpringApplication.run(HelloWorldApplication.class,args);        &#125;&#125;\n\n\nyml和properties格式区别\nyml文件的层级更加清晰直观，但是书写时需要注意格式缩进对齐\nyml格式配置文件更有利于表达复杂数据结构的配置\nproperties不如yml直观，在书写时不用特别注意格式的缩进\n\n\n必备配置\nSpring——spring核心，beans，context上下文，AOP面向切面\nWeb MVC——SPringle MVC\nJackson——JSON数据的序列化与反序列化\nValidation——Hibernate参数校验及校验API\n嵌入式Servlet Container——Tomcat\n日志框架Logging——logback，slf4j\n\n\n继承父项目的好处\n统一Java版本配置和其他的一些类库的版本\n引入第三方类库不需要加版本号，父项目会做统一管理版本\n\n\n\n三、项目文件配置\nsrc&#x2F;main&#x2F;java：项目Java文件存放位置，初始化主程序入口\nsrc&#x2F;main&#x2F;resources：存放静态资源\nsrc&#x2F;test：单元测试目录\n.gitignore：git版本管理排除文件\ntarget文件夹：项目代码构建打包结果存放位置\npom.xml：maven项目配置文件\napplication.properties(application.yml)：存放程序的各种依赖模块配置信息\n\n四、SpringBoot新版本特性\n基础环境升级\nJDK版本最低要求\n\n\n依赖组件升级\nJetty\nTomcat\nFlyway\nHibernet\nGradle\nThymeleaf\n\n\n默认软件替换\n比如：默认数据库替换、redis\n\n\n新技术的引入\n响应式编程\n\n\n默认技术支持\n彩蛋【自定义SpringBoot项目启动图样，下载banner.txt,放入resources根目录】\nhttp://www.degraeve.com/img2txt.php\nhttps://www.bootschool.net/ascii\n\n\n\n五、IDEA环境下的加载和热部署\n使用JRebel插件\ndevtools实现热加载\n\n六、常用插件\ncodota【代码补全】\nAuto filling Java call arguments【自动填充参数】\nGsonFormatPlus【JSON转实体类】\nRainbow Brackets【彩虹括号】\nMaven Helper【解决maven冲突】\nCrep Console【过滤&#x2F;修饰日志】\nBackground Image Plus【添加背景图】\n.gitgnore【git提交忽略文件】\nAlibaba Cloud Tookit【快速和阿里云连接】\nAlibaba Java Coding Guidelines【代码规范】\n\n","categories":["后端工程化学习"],"tags":["SpringBoot"]},{"title":"生命周期内的拦截过滤与监听","url":"/2022/11/25/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E7%9A%84%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E4%B8%8E%E7%9B%91%E5%90%AC/","content":"一、Servlet域对象与属性变化监听\nservlet监听器有几类：域对象的创建、销毁属性发生变化\nServletContext\nHttpSession\nServletRequest\n\n\n监听器使用了设计模式种的什么模式?\n观察者模式\n关注特定事务的创建、销毁以及变化并做出回调动作——&gt;异步\n\n\n监听器的主要接口\n\nServletContextListener\nHttpSessionListener\nServletRequestListener\n\n\n\n\n使用场景\n系统启动，初始化信息\n统计在线用户\n统计网站访问量\n\n\n监听器具体实现\n实现ServletContextListener, HttpSessionListener, ServletRequestListener, ServletRequestAttributeListener, HttpSessionAttributeListener接口，并重写方法\n在启动类@ServletComponentScan进行自动注册\n\n\n监听器测试\n上下文初始化\n请求初始化\n会话初始化\n属性变化\n请求销毁\n上下文销毁\nsession的销毁是由Servlet容器根据session超时时间等因素来控制\n\n\n作用域生命周期\nServletContext-&gt;HttpSession-&gt;ServletRequest\n\n\n\n二、过滤器和监听器的实现\n过滤器\nServlet过滤器是可用于Servlet编程Java类\n目的\n在客户端的请求访问后端资源之前，拦截这些请求\n在服务器的响应发送回客户端之前，处理这些响应\n\n\n使用场景\n授权逻辑\nIP黑名单\n对经过加密的HTTP请求数据，进行统一解密\n敏感词过滤\n\n\n特点\n可以过滤所有的请求\n能够改变请求的数据内容\n\n\n实现\n利用WebFilter注解配置过滤器\nFilterRegistraionBean方式注册过滤器\n\n\n\n\n\n三、Spring拦截器及请求链路说明\n拦截器Interceptor\n只有Spring才有\n\n\n\n拦截器实现\n实现HandlerInterceptorj接口\n实现WebMvcConfigurer接口完成拦截器的注册\n\n\n拦截器与过滤器的核心区别\n\n规范不同\n拦截器可以获取并使用Spring IoC容器中的bean\n拦截器可以访问Spring上下文中的对象\n拦截粒度：\n过滤器比拦截器的粒度更大\n适合系统级别的API的处理动作\nSpring Security大量使用了过滤器\n\n\n拦截器粒度小，适合分模块、分范围来进行统一业务逻辑处理;分模块记录日志\n\n\n\n\n拦截器实现统一访问日志\n需求：\n针对当前系统的每一次接口访问，要记录是什么人访问(用户名)、什么时间访问、访问耗时多长时间、使用什么HTTP method方法访问的、访问结果如何等，称为审计日志\n\n\n日志输出\n控制台\n输出一个单独的日志文件\n持久化\n\n\n实现步骤\n定义一个日志访问内容的实体类\n自定义一个日志拦截器\npreHandle：用户名、startTime、method\n\n\n拦截器注册\n\n\n\n\n请求链路说明\n\nCustomFilter：customFilter 请求处理之前\nCustomHandlerInterceptor：preHandle请求前调用\nCustomHandlerInterceptor：postHandler请求后调用\nCustomHandlerInterceptor：afterCompletion：请求调用完成后回调方法，在视图渲染完成后回调\nCustomFilter：customFilter 请求处理之后———doFilter之后处理响应\n\n\n\n\n\n四、自定义事件的发布与监听\n事件监听介绍\n事件发布者(事件源)\n事件监听者\n事件本身\n\n\n事件监听的特点\n异步\n解耦\n不规律性\n\n\n事件监听的实现机制\n消息队列，中间件-&gt;发布订阅模式\nJDK自带的：Java.util.EventListener\nSpring环境下的实现的事件发布监听方法\n\n\n具体实现\n自定义事件\n定义事件监听器\n写代码向ApplicationContext中添加监听器\n使用Component注解将监听器装在入spring容器\n在application.properties中配置监听器\n通过@EventListener注解实现事件监听\n\n\n\n\n\n五、应用启动监听\nSpringBoot提供了两个接口，CommandLineRunner、ApplicationRunner用于启动应用时做特殊处理，这些代码会在SpringApplication的run()方法完成之前被执行\n常用场景介绍\n将系统常用的数据加载到内存\n应用上一次运行的垃圾数据清理\n系统启动成功后的通知的发送\n\n\n代码实现\n通过@Component定义方式实现\nCommandLineRunner参数是字符串数组\n\n\nApplicationRunner：参数被放入ApplicationArguments，通过getOptionsNames()、getOptionValues()、getSourceArgs()获取参数\n\n\nCommandLineRunner和ApplicationRunner两种不同配置的运行顺序【在启动配置中加入参数，保存后启动应用】\n运行效果截图\nApplicationRunner执行优先级高于CommandLineRunner\n以Bean的形式运行的Runner优先级要低于Component注解加implements Runner接口的方式\nOrder注解只能保证同类的CommandLineRunner或ApplicationRunner的执行顺序，不能跨类保证顺序\n\n\n\n\n总结\nCommandLineRunner、ApplicationRunner的核心用法时一致的，就是用于应用前的特殊代码执行\nApplicationRunner的执行顺序先于CommandLineRunner\nApplicationRunner将参数封装成对象、提供了获取参数名、参数值等方法、操作上会方便一些\n\n\n\n六、类初始化监听\n一些初始化动作，要在bean进行初始化的时候进行，而非应用初始化的时候进行\n\n","categories":["后端工程化学习"],"tags":["SpringBoot"]}]